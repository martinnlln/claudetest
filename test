<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WIF/USDT Price Predictor</title>
    <style>
        body { font-family: Arial; }
        #chart { width: 100%; height: 600px; }
        #toggles { margin: 10px; }
        #trades-table { margin: 10px; border-collapse: collapse; }
        #trades-table th, td { border: 1px solid #ddd; padding: 8px; }
        #metrics { margin: 10px; }
    </style>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://unpkg.com/technicalindicators/dist/browser.es6.min.js"></script>
</head>
<body>
    <div id="chart"></div>
    <div id="toggles">
        <label><input type="checkbox" id="toggle-ema" checked> EMA</label>
        <label><input type="checkbox" id="toggle-sma" checked> SMA</label>
        <label><input type="checkbox" id="toggle-macd" checked> MACD</label>
        <label><input type="checkbox" id="toggle-rsi" checked> RSI</label>
        <label><input type="checkbox" id="toggle-atr" checked> ATR</label>
        <label><input type="checkbox" id="toggle-bollinger" checked> Bollinger Bands</label>
        <label><input type="checkbox" id="toggle-vwap" checked> VWAP</label>
        <label><input type="checkbox" id="toggle-obv" checked> OBV</label>
        <label><input type="checkbox" id="toggle-chaikin" checked> Chaikin</label>
        <label><input type="checkbox" id="toggle-models" checked> Model Predictions</label>
    </div>
    <table id="trades-table">
        <thead><tr><th>Time</th><th>Entry Price</th><th>Exit Price</th><th>Direction</th><th>Profit/Loss</th><th>Setup</th></tr></thead>
        <tbody></tbody>
    </table>
    <div id="metrics"></div>

    <script>
        const SYMBOL = 'WIFUSDT';
        const TOKEN_MINT = 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm';
        const SOLANA_RPC = 'https://api.mainnet-beta.solana.com';

        let chart, candleSeries;
        let indicatorSeries = {};
        let indicatorsData = {};
        let data = []; // {time, open, high, low, close, volume}
        let features = []; // Array of feature objects
        let models = {};
        let signals = [];
        let trades = [];
        let metrics = { mse: 0, mae: 0, accuracy: 0, sharpe: 0, drawdown: 0 };

        async function init() {
            chart = LightweightCharts.createChart(document.getElementById('chart'), { width: window.innerWidth, height: 600 });
            candleSeries = chart.addCandlestickSeries();
            setupToggles();
            await loadModels();
            connectWebSocket();
            await fetchHistorical();
            engineerFeatures();
            await updateData(); // Initial update
            await trainModels();
            backtest();
            updateChart();
            updateMetrics();
            setInterval(updateData, 60000);
            setInterval(predictAndSignal, 60000);
        }

        function setupToggles() {
            ['ema', 'sma', 'macd', 'rsi', 'atr', 'bollinger', 'vwap', 'obv', 'chaikin', 'models'].forEach(id => {
                document.getElementById(`toggle-${id}`).addEventListener('change', updateChart);
            });
        }

        async function fetchHistorical() {
            const klines = await fetch(`https://api.binance.com/api/v3/klines?symbol=${SYMBOL}&interval=1m&limit=1000`).then(res => res.json());
            data = klines.map(k => ({ time: Math.floor(k[0]/1000), open: parseFloat(k[1]), high: parseFloat(k[2]), low: parseFloat(k[3]), close: parseFloat(k[4]), volume: parseFloat(k[5]) }));
            candleSeries.setData(data);
        }

        function connectWebSocket() {
            const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${SYMBOL.toLowerCase()}@kline_1m`);
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.k) {
                    const k = msg.k;
                    const candle = { time: Math.floor(k.t/1000), open: parseFloat(k.o), high: parseFloat(k.h), low: parseFloat(k.l), close: parseFloat(k.c), volume: parseFloat(k.v) };
                    const last = data[data.length - 1];
                    if (candle.time === last.time) {
                        data[data.length - 1] = candle;
                        candleSeries.update(candle);
                    } else {
                        data.push(candle);
                        candleSeries.update(candle);
                    }
                    engineerFeatures();
                    updateChart();
                }
            };
        }

        async function updateData() {
            const depth = await fetch(`https://api.binance.com/api/v3/depth?symbol=${SYMBOL}&limit=100`).then(res => res.json());
            const tradesRecent = await fetch(`https://api.binance.com/api/v3/trades?symbol=${SYMBOL}&limit=1000`).then(res => res.json());
            const coingecko = await fetch('https://api.coingecko.com/api/v3/coins/dogwifhat/market_chart?vs_currency=usd&days=1&interval=minute').then(res => res.json());

            const whales = {transactions: []}; // No public API without key

            const holdersRes = await fetch(SOLANA_RPC, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'getTokenLargestAccounts', params: [TOKEN_MINT, {commitment: 'finalized'}] })
            }).then(res => res.json());
            const holders = holdersRes.result ? holdersRes.result.value : [];

            const reddit = await fetch('https://www.reddit.com/search.json?q=WIF%20cryptocurrency&sort=new&limit=100').then(res => res.json() || {data: {children: []}});

            const trends = {interest_over_time: {timeline_data: [{values: [0]}]}}; // No public API without key

            const latestFeature = {
                bidAskSpread: parseFloat(depth.asks[0][0]) - parseFloat(depth.bids[0][0]),
                depthImbalance: calculateDepthImbalance(depth),
                tradeImbalance: calculateTradeImbalance(tradesRecent),
                timeBetweenTrades: calculateTimeBetweenTrades(tradesRecent),
                exchangeInflow: calculateExchangeInflow(whales.transactions),
                exchangeOutflow: calculateExchangeOutflow(whales.transactions),
                topHolderConcentration: calculateTopHolderConcentration(holders),
                tokenVelocity: calculateTokenVelocity(whales.transactions),
                mintBurn: calculateMintBurn(whales.transactions),
                lpEvents: calculateLpEvents(whales.transactions),
                socialSentiment: analyzeSocialSentiment(reddit.data.children),
                trendsScore: trends.interest_over_time.timeline_data.length > 0 ? trends.interest_over_time.timeline_data[0].values[0] : 0
            };

            latestFeature.whalePressure = calculateWhalePressure(latestFeature);
            latestFeature.liquidityAlarm = calculateLiquidityAlarm(latestFeature);
            latestFeature.holderCohortMomentum = calculateHolderCohortMomentum(holders);
            latestFeature.memeMomentum = calculateMemeMomentum(latestFeature);

            features.push(latestFeature);
        }

        function engineerFeatures() {
            const TI = technicalindicators;
            const closes = data.map(d => d.close);
            const highs = data.map(d => d.high);
            const lows = data.map(d => d.low);
            const volumes = data.map(d => d.volume);
            const period14 = 14;
            const period20 = 20;
            const period12 = 12;
            const period26 = 26;
            const period9 = 9;
            const period21 = 21;

            indicatorsData.ema = new TI.EMA({ period: period12, values: closes }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
            indicatorsData.sma = new TI.SMA({ period: period20, values: closes }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
            indicatorsData.macd = new TI.MACD({ values: closes, fastPeriod: period12, slowPeriod: period26, signalPeriod: period9 }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, MACD: v.MACD, signal: v.signal, histogram: v.histogram }));
            indicatorsData.rsi = new TI.RSI({ period: period14, values: closes }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
            indicatorsData.atr = new TI.ATR({ high: highs, low: lows, close: closes, period: period14 }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
            indicatorsData.bollinger = new TI.BollingerBands({ period: period20, stdDev: 2, values: closes }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, middle: v.middle, upper: v.upper, lower: v.lower }));
            indicatorsData.vwap = calculateVWAP(highs, lows, closes, volumes).map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
            indicatorsData.obv = new TI.OBV({ close: closes, volume: volumes }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
            indicatorsData.chaikin = new TI.ChaikinMoneyFlow({ high: highs, low: lows, close: closes, volume: volumes, period: period21 }).result.map((v, i) => ({ time: data[i] ? data[i].time : 0, value: v }));
        }

        function calculateVWAP(highs, lows, closes, volumes) {
            let vwap = [];
            let cumVolume = 0;
            let cumTypicalVolume = 0;
            for (let i = 0; i < closes.length; i++) {
                const typical = (highs[i] + lows[i] + closes[i]) / 3;
                cumTypicalVolume += typical * volumes[i];
                cumVolume += volumes[i];
                vwap.push(cumTypicalVolume / cumVolume || 0);
            }
            return vwap;
        }

        async function loadModels() {
            const featureDim = 16; // bidAskSpread, depthImbalance, tradeImbalance, timeBetweenTrades, exchangeInflow, exchangeOutflow, topHolderConcentration, tokenVelocity, mintBurn, lpEvents, socialSentiment, trendsScore, whalePressure, liquidityAlarm, holderCohortMomentum, memeMomentum
            const timeSteps = 60;

            models.linear = tf.sequential();
            models.linear.add(tf.layers.dense({ units: 1, inputShape: [featureDim] }));
            models.linear.compile({ optimizer: 'sgd', loss: 'meanSquaredError' });

            models.mlp = tf.sequential();
            models.mlp.add(tf.layers.dense({ units: 128, activation: 'relu', inputShape: [featureDim] }));
            models.mlp.add(tf.layers.dense({ units: 64, activation: 'relu' }));
            models.mlp.add(tf.layers.dense({ units: 1 }));
            models.mlp.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            models.lstm = tf.sequential();
            models.lstm.add(tf.layers.lstm({ units: 64, returnSequences: true, inputShape: [timeSteps, featureDim] }));
            models.lstm.add(tf.layers.lstm({ units: 32 }));
            models.lstm.add(tf.layers.dense({ units: 1 }));
            models.lstm.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            models.gru = tf.sequential();
            models.gru.add(tf.layers.gru({ units: 64, returnSequences: true, inputShape: [timeSteps, featureDim] }));
            models.gru.add(tf.layers.gru({ units: 32 }));
            models.gru.add(tf.layers.dense({ units: 1 }));
            models.gru.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            models.cnn = tf.sequential();
            models.cnn.add(tf.layers.conv1d({ filters: 32, kernelSize: 5, activation: 'relu', inputShape: [timeSteps, featureDim] }));
            models.cnn.add(tf.layers.maxPooling1d({ poolSize: 2 }));
            models.cnn.add(tf.layers.flatten());
            models.cnn.add(tf.layers.dense({ units: 1 }));
            models.cnn.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            models.transformer = buildTransformerModel(timeSteps, featureDim);
            models.transformer.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            models.autoencoder = buildAutoencoder(featureDim);
            models.autoencoder.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            models.ensemble = { predict: async (x) => {
                const preds = await Promise.all([models.linear, models.mlp, models.lstm, models.gru, models.cnn, models.transformer].map(m => m.predict(x)));
                return tf.mean(tf.stack(preds), 0);
            }};
        }

        function buildTransformerModel(timeSteps, featureDim) {
            const input = tf.input({ shape: [timeSteps, featureDim] });
            let x = tf.layers.multiHeadAttention({ numHeads: 4, keyDim: 64 }).apply([input, input]);
            x = tf.layers.layerNormalization().apply(x);
            x = tf.layers.dense({ units: featureDim, activation: 'relu' }).apply(x);
            x = tf.layers.globalAveragePooling1d().apply(x);
            const output = tf.layers.dense({ units: 1 }).apply(x);
            return tf.model({ inputs: input, outputs: output });
        }

        function buildAutoencoder(featureDim) {
            const input = tf.input({ shape: [featureDim] });
            let x = tf.layers.dense({ units: 32, activation: 'relu' }).apply(input);
            x = tf.layers.dense({ units: 16, activation: 'relu' }).apply(x);
            x = tf.layers.dense({ units: 32, activation: 'relu' }).apply(x);
            const output = tf.layers.dense({ units: featureDim }).apply(x);
            return tf.model({ inputs: input, outputs: output });
        }

        async function trainModels() {
            const timeSteps = 60;
            const xs = [];
            const ys = [];
            if (features.length < timeSteps) return;
            const featureKeys = Object.keys(features[0]);
            for (let i = timeSteps; i < features.length; i++) {
                const window = features.slice(i - timeSteps, i).map(f => featureKeys.map(k => f[k] || 0));
                xs.push(window);
                ys.push(data[i].close - data[i - 1].close);
            }
            if (xs.length === 0) return;
            const xsTensor = tf.tensor3d(xs);
            const ysTensor = tf.tensor1d(ys);
            const xs2d = tf.reshape(xsTensor, [xs.length, featureKeys.length]);
            const ys2d = tf.reshape(ysTensor, [xs.length, 1]);

            await models.linear.fit(xs2d, ysTensor, { epochs: 20 });
            await models.mlp.fit(xs2d, ysTensor, { epochs: 20 });
            await models.lstm.fit(xsTensor, ysTensor, { epochs: 20 });
            await models.gru.fit(xsTensor, ysTensor, { epochs: 20 });
            await models.cnn.fit(xsTensor, ysTensor, { epochs: 20 });
            await models.transformer.fit(xsTensor, ysTensor, { epochs: 20 });
            await models.autoencoder.fit(xs2d, xs2d, { epochs: 20 });
        }

        function backtest() {
            const timeSteps = 60;
            const slippage = 0.001;
            const fee = 0.0005;
            let portfolio = 10000;
            let position = 0;
            let returns = [];
            let peak = portfolio;
            let preds = [];
            let actuals = [];
            for (let i = timeSteps; i < data.length; i++) {
                if (features.length < i - timeSteps + 1) continue;
                const window = tf.tensor3d([features.slice(i - timeSteps, i).map(f => Object.values(f))]);
                const pred = models.ensemble.predict(window).dataSync()[0];
                const actual = data[i].close - data[i - 1].close;
                preds.push(pred);
                actuals.push(actual);
                const signal = pred > 0 ? 1 : -1;
                if (signal > 0 && position <= 0) {
                    position = portfolio / data[i].close * (1 - fee - slippage);
                    portfolio = 0;
                    trades.push({ time: data[i].time * 1000, entry: data[i].close, direction: 'buy', setup: 'Ensemble signal positive', exit: null, pnl: null });
                } else if (signal < 0 && position > 0) {
                    portfolio = position * data[i].close * (1 - fee - slippage);
                    position = 0;
                    const lastTrade = trades[trades.length - 1];
                    lastTrade.exit = data[i].close;
                    lastTrade.pnl = (lastTrade.exit - lastTrade.entry) / lastTrade.entry * 100;
                    returns.push(lastTrade.pnl / 100);
                    peak = Math.max(peak, portfolio);
                }
            }
            const meanRet = returns.reduce((a, b) => a + b, 0) / returns.length || 0;
            const stdRet = Math.sqrt(returns.reduce((a, b) => a + Math.pow(b - meanRet, 2), 0) / returns.length) || 0;
            metrics.sharpe = stdRet ? meanRet / stdRet * Math.sqrt(252 * 1440) : 0; // Annualized
            metrics.drawdown = peak ? (peak - portfolio) / peak * 100 : 0;
            metrics.mse = preds.reduce((a, b, i) => a + Math.pow(b - actuals[i], 2), 0) / preds.length || 0;
            metrics.mae = preds.reduce((a, b, i) => a + Math.abs(b - actuals[i]), 0) / preds.length || 0;
            metrics.accuracy = preds.filter((p, i) => Math.sign(p) === Math.sign(actuals[i])).length / preds.length * 100 || 0;
            updateTable();
            updateMetrics();
        }

        async function predictAndSignal() {
            if (features.length < 60) return;
            const window = tf.tensor3d([features.slice(-60).map(f => Object.values(f))]);
            const pred = (await models.ensemble.predict(window)).dataSync()[0];
            const anomaly = detectAnomaly(tf.reshape(window, [1, Object.keys(features[0]).length]));
            if (anomaly) return;
            const direction = pred > 0 ? 'buy' : 'sell';
            signals.push({ time: data[data.length - 1].time, type: direction, price: data[data.length - 1].close });
            executeTrade(direction, pred);
            updateChart();
        }

        function detectAnomaly(x) {
            const recon = models.autoencoder.predict(x);
            const error = tf.mean(tf.square(tf.sub(x, recon))).dataSync()[0];
            return error > 0.1;
        }

        function executeTrade(direction, pred) {
            const entry = data[data.length - 1].close;
            trades.push({ time: Date.now(), entry, direction, setup: `Ensemble pred: ${pred.toFixed(4)}`, exit: null, pnl: null });
            setTimeout(() => {
                if (data.length === 0) return;
                const current = data[data.length - 1].close;
                const lastTrade = trades[trades.length - 1];
                lastTrade.exit = current;
                lastTrade.pnl = (direction === 'buy' ? (current - entry) : (entry - current)) / entry * 100;
                updateTable();
            }, 300000);
        }

        function updateChart() {
            Object.values(indicatorSeries).forEach(series => {
                if (Array.isArray(series)) {
                    series.forEach(s => chart.removeSeries(s));
                } else {
                    chart.removeSeries(series);
                }
            });
            indicatorSeries = {};

            if (document.getElementById('toggle-ema').checked) {
                indicatorSeries.ema = chart.addLineSeries({ color: 'blue' });
                indicatorSeries.ema.setData(indicatorsData.ema || []);
            }
            if (document.getElementById('toggle-sma').checked) {
                indicatorSeries.sma = chart.addLineSeries({ color: 'green' });
                indicatorSeries.sma.setData(indicatorsData.sma || []);
            }
            if (document.getElementById('toggle-macd').checked) {
                indicatorSeries.macdLine = chart.addLineSeries({ color: 'red' });
                indicatorSeries.macdLine.setData((indicatorsData.macd || []).map(v => ({ time: v.time, value: v.MACD })));
                indicatorSeries.signalLine = chart.addLineSeries({ color: 'orange' });
                indicatorSeries.signalLine.setData((indicatorsData.macd || []).map(v => ({ time: v.time, value: v.signal })));
                indicatorSeries.histogram = chart.addHistogramSeries({ color: 'purple' });
                indicatorSeries.histogram.setData((indicatorsData.macd || []).map(v => ({ time: v.time, value: v.histogram })));
                indicatorSeries.macd = [indicatorSeries.macdLine, indicatorSeries.signalLine, indicatorSeries.histogram];
            }
            if (document.getElementById('toggle-rsi').checked) {
                indicatorSeries.rsi = chart.addLineSeries({ color: 'cyan' });
                indicatorSeries.rsi.setData(indicatorsData.rsi || []);
            }
            if (document.getElementById('toggle-atr').checked) {
                indicatorSeries.atr = chart.addLineSeries({ color: 'magenta' });
                indicatorSeries.atr.setData(indicatorsData.atr || []);
            }
            if (document.getElementById('toggle-bollinger').checked) {
                indicatorSeries.bolMiddle = chart.addLineSeries({ color: 'black' });
                indicatorSeries.bolMiddle.setData((indicatorsData.bollinger || []).map(v => ({ time: v.time, value: v.middle })));
                indicatorSeries.bolUpper = chart.addLineSeries({ color: 'gray' });
                indicatorSeries.bolUpper.setData((indicatorsData.bollinger || []).map(v => ({ time: v.time, value: v.upper })));
                indicatorSeries.bolLower = chart.addLineSeries({ color: 'gray' });
                indicatorSeries.bolLower.setData((indicatorsData.bollinger || []).map(v => ({ time: v.time, value: v.lower })));
                indicatorSeries.bollinger = [indicatorSeries.bolMiddle, indicatorSeries.bolUpper, indicatorSeries.bolLower];
            }
            if (document.getElementById('toggle-vwap').checked) {
                indicatorSeries.vwap = chart.addLineSeries({ color: 'brown' });
                indicatorSeries.vwap.setData(indicatorsData.vwap || []);
            }
            if (document.getElementById('toggle-obv').checked) {
                indicatorSeries.obv = chart.addLineSeries({ color: 'pink' });
                indicatorSeries.obv.setData(indicatorsData.obv || []);
            }
            if (document.getElementById('toggle-chaikin').checked) {
                indicatorSeries.chaikin = chart.addLineSeries({ color: 'lime' });
                indicatorSeries.chaikin.setData(indicatorsData.chaikin || []);
            }
            if (document.getElementById('toggle-models').checked) {
                candleSeries.setMarkers(signals.map(s => ({ time: s.time, position: s.type === 'buy' ? 'belowBar' : 'aboveBar', color: s.type === 'buy' ? '#00FF00' : '#FF0000', shape: 'circle', text: s.type })));
            } else {
                candleSeries.setMarkers([]);
            }
        }

        function updateTable() {
            const tbody = document.querySelector('#trades-table tbody');
            tbody.innerHTML = trades.map(t => `<tr><td>${new Date(t.time).toLocaleString()}</td><td>${t.entry.toFixed(4)}</td><td>${t.exit ? t.exit.toFixed(4) : 'Open'}</td><td>${t.direction}</td><td>${t.pnl ? t.pnl.toFixed(2) + '%' : '0%'}</td><td>${t.setup}</td></tr>`).join('');
        }

        function updateMetrics() {
            document.getElementById('metrics').innerHTML = `MSE: ${metrics.mse.toFixed(4)} | MAE: ${metrics.mae.toFixed(4)} | Accuracy: ${metrics.accuracy.toFixed(2)}% | Sharpe: ${metrics.sharpe.toFixed(2)} | Drawdown: ${metrics.drawdown.toFixed(2)}%`;
        }

        // Helper functions
        function calculateDepthImbalance(depth) {
            const bidVol = depth.bids.reduce((a, b) => a + parseFloat(b[1]), 0);
            const askVol = depth.asks.reduce((a, b) => a + parseFloat(b[1]), 0);
            return (bidVol - askVol) / (bidVol + askVol) || 0;
        }

        function calculateTradeImbalance(trades) {
            const buys = trades.filter(t => !t.isBuyerMaker).reduce((a, t) => a + parseFloat(t.qty), 0);
            const sells = trades.filter(t => t.isBuyerMaker).reduce((a, t) => a + parseFloat(t.qty), 0);
            return (buys - sells) / (buys + sells) || 0;
        }

        function calculateTimeBetweenTrades(trades) {
            if (trades.length < 2) return 0;
            const times = trades.map(t => t.time);
            const diffs = times.slice(1).map((t, i) => t - times[i]);
            return diffs.reduce((a, b) => a + b, 0) / diffs.length / 1000 || 0;
        }

        function calculateExchangeInflow(transactions) {
            return transactions.filter(t => t.to && t.to.owner_type === 'exchange').reduce((a, t) => a + (t.amount_usd || 0), 0);
        }

        function calculateExchangeOutflow(transactions) {
            return transactions.filter(t => t.from && t.from.owner_type === 'exchange').reduce((a, t) => a + (t.amount_usd || 0), 0);
        }

        function calculateTopHolderConcentration(holders) {
            const total = holders.reduce((a, h) => a + (h.uiAmount || 0), 0);
            const top10 = holders.slice(0, 10).reduce((a, h) => a + (h.uiAmount || 0), 0);
            return total ? top10 / total : 0;
        }

        function calculateTokenVelocity(transactions) {
            return transactions.length / 60 || 0;
        }

        function calculateMintBurn(transactions) {
            return transactions.filter(t => t.type === 'mint').length - transactions.filter(t => t.type === 'burn').length;
        }

        function calculateLpEvents(transactions) {
            return transactions.filter(t => t.to && t.to.owner === 'liquidity_pool' || t.from && t.from.owner === 'liquidity_pool').length;
        }

        function analyzeSocialSentiment(posts) {
            const positive = posts.filter(p => p.data.title.toLowerCase().includes('bullish') || p.data.title.toLowerCase().includes('up')).length;
            const negative = posts.filter(p => p.data.title.toLowerCase().includes('bearish') || p.data.title.toLowerCase().includes('down')).length;
            return posts.length ? (positive - negative) / posts.length : 0;
        }

        function calculateWhalePressure(feature) {
            return feature.exchangeInflow - feature.exchangeOutflow;
        }

        function calculateLiquidityAlarm(feature) {
            return feature.depthImbalance * feature.bidAskSpread;
        }

        function calculateHolderCohortMomentum(holders) {
            return holders.length > 0 ? holders[0].uiAmount - holders[holders.length - 1].uiAmount : 0;
        }

        function calculateMemeMomentum(feature) {
            return feature.socialSentiment + feature.trendsScore / 100;
        }

        init();
    </script>
</body>
</html>
