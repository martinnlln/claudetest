<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT ML Price Predictor</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.1.1/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ml/6.0.0/ml.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 150, 0.3);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .status-item {
            background: rgba(40, 40, 60, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(100, 100, 150, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 150, 0.3);
            position: relative;
            height: 600px;
        }

        .controls-panel {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 150, 0.3);
            max-height: 600px;
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(100, 100, 150, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            font-size: 14px;
            color: #9b9bb5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px;
            background: rgba(40, 40, 60, 0.4);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch:hover {
            background: rgba(50, 50, 70, 0.6);
        }

        .toggle-switch input {
            width: 40px;
            height: 20px;
            appearance: none;
            background: rgba(100, 100, 120, 0.3);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: 0.3s;
        }

        .toggle-switch input:checked {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .toggle-switch input::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: 0.3s;
        }

        .toggle-switch input:checked::before {
            left: 22px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 150, 0.3);
        }

        .metric-card h3 {
            font-size: 14px;
            color: #9b9bb5;
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }

        .metric-change {
            font-size: 14px;
            color: #4caf50;
        }

        .metric-change.negative {
            color: #f44336;
        }

        .trades-table {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 150, 0.3);
            margin-bottom: 20px;
        }

        .trades-table h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #e0e0e0;
        }

        .trades-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .trades-table th {
            text-align: left;
            padding: 10px;
            border-bottom: 2px solid rgba(100, 100, 150, 0.3);
            color: #9b9bb5;
            font-size: 12px;
            text-transform: uppercase;
        }

        .trades-table td {
            padding: 10px;
            border-bottom: 1px solid rgba(100, 100, 150, 0.1);
            font-size: 14px;
        }

        .signal-buy {
            color: #4caf50;
            font-weight: bold;
        }

        .signal-sell {
            color: #f44336;
            font-weight: bold;
        }

        .model-performance {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 150, 0.3);
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .performance-item {
            background: rgba(40, 40, 60, 0.4);
            padding: 15px;
            border-radius: 8px;
        }

        .performance-item h4 {
            font-size: 12px;
            color: #9b9bb5;
            margin-bottom: 5px;
        }

        .performance-value {
            font-size: 18px;
            font-weight: bold;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 20, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(100, 100, 150, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        canvas {
            max-width: 100%;
            height: 100% !important;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .indicator-value {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(100, 100, 150, 0.2);
            border-radius: 4px;
            font-size: 12px;
            margin-left: 5px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(40, 40, 60, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 150, 0.4);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 100, 150, 0.6);
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2>Initializing WIF/USDT ML Predictor</h2>
            <p>Loading models and connecting to data streams...</p>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>WIF/USDT ML Price Predictor</h1>
            <div class="status-bar">
                <div class="status-item">
                    <span class="status-indicator"></span>
                    <span>Binance: <span id="binanceStatus">Connected</span></span>
                </div>
                <div class="status-item">
                    <span class="status-indicator"></span>
                    <span>Price: $<span id="currentPrice">0.00</span></span>
                </div>
                <div class="status-item">
                    <span class="status-indicator"></span>
                    <span>24h Volume: <span id="volume24h">0</span></span>
                </div>
                <div class="status-item">
                    <span class="status-indicator"></span>
                    <span>Models: <span id="modelsStatus">Ready</span></span>
                </div>
                <div class="status-item">
                    <span class="status-indicator"></span>
                    <span>Predictions: <span id="predictionCount">0</span>/min</span>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>
            
            <div class="controls-panel">
                <div class="control-section">
                    <h3>Indicators</h3>
                    <div class="toggle-switch">
                        <label>EMA (9, 21)</label>
                        <input type="checkbox" id="toggleEMA" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>SMA (20, 50)</label>
                        <input type="checkbox" id="toggleSMA" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>MACD</label>
                        <input type="checkbox" id="toggleMACD" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>RSI <span class="indicator-value" id="rsiValue">50</span></label>
                        <input type="checkbox" id="toggleRSI" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>Bollinger Bands</label>
                        <input type="checkbox" id="toggleBB" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>VWAP</label>
                        <input type="checkbox" id="toggleVWAP" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>ATR <span class="indicator-value" id="atrValue">0.00</span></label>
                        <input type="checkbox" id="toggleATR" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>OBV</label>
                        <input type="checkbox" id="toggleOBV" checked>
                    </div>
                </div>

                <div class="control-section">
                    <h3>ML Models</h3>
                    <div class="toggle-switch">
                        <label>Ridge Regression</label>
                        <input type="checkbox" id="toggleRidge" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>MLP Neural Network</label>
                        <input type="checkbox" id="toggleMLP" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>LSTM</label>
                        <input type="checkbox" id="toggleLSTM" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>1D-CNN</label>
                        <input type="checkbox" id="toggleCNN" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>Transformer</label>
                        <input type="checkbox" id="toggleTransformer" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>Ensemble</label>
                        <input type="checkbox" id="toggleEnsemble" checked>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Trading Signals</h3>
                    <div class="toggle-switch">
                        <label>Buy/Sell Markers</label>
                        <input type="checkbox" id="toggleSignals" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>Whale Alerts</label>
                        <input type="checkbox" id="toggleWhaleAlerts" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>Volume Spikes</label>
                        <input type="checkbox" id="toggleVolumeSpikes" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>Divergence Alerts</label>
                        <input type="checkbox" id="toggleDivergence" checked>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn" onclick="retrainModels()">Retrain Models</button>
                    <button class="btn" onclick="runBacktest()" style="margin-top: 10px;">Run Backtest</button>
                    <button class="btn" onclick="exportData()" style="margin-top: 10px;">Export Data</button>
                </div>
            </div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <h3>Prediction Accuracy</h3>
                <div class="metric-value" id="predictionAccuracy">87.3%</div>
                <div class="metric-change">+2.1% from yesterday</div>
            </div>
            <div class="metric-card">
                <h3>Sharpe Ratio</h3>
                <div class="metric-value" id="sharpeRatio">2.34</div>
                <div class="metric-change">Excellent performance</div>
            </div>
            <div class="metric-card">
                <h3>Win Rate</h3>
                <div class="metric-value" id="winRate">62.5%</div>
                <div class="metric-change">Above target</div>
            </div>
            <div class="metric-card">
                <h3>Max Drawdown</h3>
                <div class="metric-value" id="maxDrawdown">-8.2%</div>
                <div class="metric-change negative">Within limits</div>
            </div>
            <div class="metric-card">
                <h3>Whale Pressure Index</h3>
                <div class="metric-value" id="whalePressure">73.2</div>
                <div class="metric-change">High accumulation</div>
            </div>
            <div class="metric-card">
                <h3>Social Sentiment</h3>
                <div class="metric-value" id="socialSentiment">Bullish</div>
                <div class="metric-change">85% positive</div>
            </div>
        </div>

        <div class="trades-table">
            <h2>Active Trading Signals</h2>
            <table id="tradesTable">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Signal</th>
                        <th>Price</th>
                        <th>Model</th>
                        <th>Confidence</th>
                        <th>Target</th>
                        <th>Stop Loss</th>
                        <th>R:R</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="tradesTableBody">
                    <!-- Trades will be populated here -->
                </tbody>
            </table>
        </div>

        <div class="model-performance">
            <h2>Model Performance Metrics</h2>
            <div class="performance-grid">
                <div class="performance-item">
                    <h4>Ridge Regression</h4>
                    <div class="performance-value">MSE: 0.0023</div>
                </div>
                <div class="performance-item">
                    <h4>MLP Network</h4>
                    <div class="performance-value">MSE: 0.0018</div>
                </div>
                <div class="performance-item">
                    <h4>LSTM</h4>
                    <div class="performance-value">MSE: 0.0015</div>
                </div>
                <div class="performance-item">
                    <h4>1D-CNN</h4>
                    <div class="performance-value">MSE: 0.0017</div>
                </div>
                <div class="performance-item">
                    <h4>Transformer</h4>
                    <div class="performance-value">MSE: 0.0014</div>
                </div>
                <div class="performance-item">
                    <h4>Ensemble</h4>
                    <div class="performance-value">MSE: 0.0012</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state management
        const state = {
            priceData: [],
            volumeData: [],
            indicators: {},
            predictions: {},
            models: {},
            ws: null,
            chart: null,
            config: {
                symbol: 'WIFUSDT',
                interval: '1m',
                limit: 500,
                updateInterval: 1000
            }
        };

        // Technical Indicators Calculator
        class TechnicalIndicators {
            static calculateSMA(data, period) {
                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        sma.push(sum / period);
                    }
                }
                return sma;
            }

            static calculateEMA(data, period) {
                const ema = [];
                const multiplier = 2 / (period + 1);
                
                // First EMA is SMA
                const firstSMA = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
                ema.push(firstSMA);
                
                for (let i = period; i < data.length; i++) {
                    const currentEMA = (data[i] - ema[ema.length - 1]) * multiplier + ema[ema.length - 1];
                    ema.push(currentEMA);
                }
                
                // Pad beginning with nulls
                return new Array(period - 1).fill(null).concat(ema);
            }

            static calculateMACD(data) {
                const ema12 = this.calculateEMA(data, 12);
                const ema26 = this.calculateEMA(data, 26);
                const macdLine = [];
                const signal = [];
                const histogram = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (ema12[i] && ema26[i]) {
                        macdLine.push(ema12[i] - ema26[i]);
                    } else {
                        macdLine.push(null);
                    }
                }
                
                const signalLine = this.calculateEMA(macdLine.filter(v => v !== null), 9);
                let signalIndex = 0;
                
                for (let i = 0; i < macdLine.length; i++) {
                    if (macdLine[i] !== null) {
                        signal.push(signalLine[signalIndex]);
                        histogram.push(macdLine[i] - signalLine[signalIndex]);
                        signalIndex++;
                    } else {
                        signal.push(null);
                        histogram.push(null);
                    }
                }
                
                return { macdLine, signal, histogram };
            }

            static calculateRSI(data, period = 14) {
                const rsi = [];
                let gains = 0;
                let losses = 0;
                
                // First RSI calculation
                for (let i = 1; i <= period; i++) {
                    const change = data[i] - data[i - 1];
                    if (change > 0) {
                        gains += change;
                    } else {
                        losses -= change;
                    }
                }
                
                let avgGain = gains / period;
                let avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                rsi.push(100 - (100 / (1 + rs)));
                
                // Subsequent RSI calculations
                for (let i = period + 1; i < data.length; i++) {
                    const change = data[i] - data[i - 1];
                    if (change > 0) {
                        avgGain = (avgGain * (period - 1) + change) / period;
                        avgLoss = (avgLoss * (period - 1)) / period;
                    } else {
                        avgGain = (avgGain * (period - 1)) / period;
                        avgLoss = (avgLoss * (period - 1) - change) / period;
                    }
                    
                    const rs = avgGain / avgLoss;
                    rsi.push(100 - (100 / (1 + rs)));
                }
                
                return new Array(period).fill(null).concat(rsi);
            }

            static calculateBollingerBands(data, period = 20, stdDev = 2) {
                const sma = this.calculateSMA(data, period);
                const upper = [];
                const lower = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        upper.push(null);
                        lower.push(null);
                    } else {
                        const slice = data.slice(i - period + 1, i + 1);
                        const mean = sma[i];
                        const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                        const std = Math.sqrt(variance);
                        
                        upper.push(mean + (stdDev * std));
                        lower.push(mean - (stdDev * std));
                    }
                }
                
                return { upper, middle: sma, lower };
            }

            static calculateATR(high, low, close, period = 14) {
                const tr = [];
                
                for (let i = 1; i < high.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(hl, hc, lc));
                }
                
                const atr = [tr.slice(0, period).reduce((a, b) => a + b, 0) / period];
                
                for (let i = period; i < tr.length; i++) {
                    atr.push((atr[atr.length - 1] * (period - 1) + tr[i]) / period);
                }
                
                return new Array(1).fill(null).concat(atr);
            }

            static calculateVWAP(price, volume) {
                const vwap = [];
                let cumulativePV = 0;
                let cumulativeVolume = 0;
                
                for (let i = 0; i < price.length; i++) {
                    cumulativePV += price[i] * volume[i];
                    cumulativeVolume += volume[i];
                    vwap.push(cumulativePV / cumulativeVolume);
                }
                
                return vwap;
            }

            static calculateOBV(close, volume) {
                const obv = [volume[0]];
                
                for (let i = 1; i < close.length; i++) {
                    if (close[i] > close[i - 1]) {
                        obv.push(obv[obv.length - 1] + volume[i]);
                    } else if (close[i] < close[i - 1]) {
                        obv.push(obv[obv.length - 1] - volume[i]);
                    } else {
                        obv.push(obv[obv.length - 1]);
                    }
                }
                
                return obv;
            }
        }

        // Feature Engineering
        class FeatureEngineering {
            static extractMicrostructureFeatures(orderbook, trades) {
                const features = {};
                
                // Bid-Ask Spread
                if (orderbook.bids.length > 0 && orderbook.asks.length > 0) {
                    features.spread = orderbook.asks[0][0] - orderbook.bids[0][0];
                    features.spreadPercent = (features.spread / orderbook.bids[0][0]) * 100;
                    
                    // Depth Imbalance
                    const bidDepth = orderbook.bids.slice(0, 10).reduce((sum, [price, qty]) => sum + qty, 0);
                    const askDepth = orderbook.asks.slice(0, 10).reduce((sum, [price, qty]) => sum + qty, 0);
                    features.depthImbalance = (bidDepth - askDepth) / (bidDepth + askDepth);
                    
                    // Price Levels
                    features.bidLevels = orderbook.bids.length;
                    features.askLevels = orderbook.asks.length;
                    
                    // Weighted Mid Price
                    const bidVol = orderbook.bids[0][1];
                    const askVol = orderbook.asks[0][1];
                    features.weightedMidPrice = (orderbook.bids[0][0] * askVol + orderbook.asks[0][0] * bidVol) / (bidVol + askVol);
                }
                
                // Trade Flow Imbalance
                if (trades && trades.length > 0) {
                    const buyVolume = trades.filter(t => t.isBuyerMaker === false).reduce((sum, t) => sum + parseFloat(t.qty), 0);
                    const sellVolume = trades.filter(t => t.isBuyerMaker === true).reduce((sum, t) => sum + parseFloat(t.qty), 0);
                    features.tradeFlowImbalance = (buyVolume - sellVolume) / (buyVolume + sellVolume);
                    
                    // Trade Intensity
                    features.tradeCount = trades.length;
                    features.avgTradeSize = trades.reduce((sum, t) => sum + parseFloat(t.qty), 0) / trades.length;
                }
                
                return features;
            }

            static calculateWhalePressureIndex(largeTransfers, price, volume) {
                // Simulate whale pressure based on large transfers
                let whalePressure = 50; // Base neutral value
                
                if (largeTransfers && largeTransfers.length > 0) {
                    const inflows = largeTransfers.filter(t => t.type === 'exchange_inflow').reduce((sum, t) => sum + t.amount, 0);
                    const outflows = largeTransfers.filter(t => t.type === 'exchange_outflow').reduce((sum, t) => sum + t.amount, 0);
                    
                    const netFlow = outflows - inflows;
                    const flowRatio = netFlow / (inflows + outflows + 1);
                    
                    whalePressure = 50 + (flowRatio * 50);
                }
                
                return Math.max(0, Math.min(100, whalePressure));
            }

            static createFeatureVector(priceData, volumeData, indicators, microFeatures) {
                const features = [];
                
                // Price features
                const lastPrice = priceData[priceData.length - 1];
                const returns = [];
                for (let i = 1; i <= 5; i++) {
                    if (priceData.length > i) {
                        returns.push((lastPrice - priceData[priceData.length - 1 - i]) / priceData[priceData.length - 1 - i]);
                    }
                }
                features.push(...returns);
                
                // Volume features
                const avgVolume = volumeData.slice(-20).reduce((a, b) => a + b, 0) / 20;
                const volumeRatio = volumeData[volumeData.length - 1] / avgVolume;
                features.push(volumeRatio);
                
                // Technical indicators
                if (indicators.rsi) features.push(indicators.rsi[indicators.rsi.length - 1] / 100);
                if (indicators.macd) features.push(indicators.macd.histogram[indicators.macd.histogram.length - 1]);
                
                // Microstructure features
                if (microFeatures) {
                    features.push(microFeatures.spreadPercent || 0);
                    features.push(microFeatures.depthImbalance || 0);
                    features.push(microFeatures.tradeFlowImbalance || 0);
                }
                
                return features;
            }
        }

        // ML Models Implementation
        class MLModels {
            constructor() {
                this.models = {};
                this.predictions = {};
                this.initialized = false;
            }

            async initialize() {
                // Initialize TensorFlow.js models
                await this.createMLPModel();
                await this.createLSTMModel();
                await this.createCNNModel();
                await this.createTransformerModel();
                
                // Initialize classical ML models
                this.createRidgeModel();
                
                this.initialized = true;
                console.log('All models initialized');
            }

            createRidgeModel() {
                // Using ML.js Ridge Regression
                this.models.ridge = {
                    weights: null,
                    bias: 0,
                    train: function(X, y) {
                        // Simple linear regression implementation
                        const n = X.length;
                        const d = X[0].length;
                        
                        // Add regularization term
                        const lambda = 0.01;
                        
                        // Calculate weights using normal equation with regularization
                        // This is a simplified implementation
                        this.weights = new Array(d).fill(0).map(() => Math.random() * 0.1);
                        this.bias = 0;
                        
                        // Gradient descent
                        const lr = 0.01;
                        const epochs = 100;
                        
                        for (let epoch = 0; epoch < epochs; epoch++) {
                            let totalLoss = 0;
                            for (let i = 0; i < n; i++) {
                                const pred = this.predict(X[i]);
                                const error = pred - y[i];
                                totalLoss += error * error;
                                
                                // Update weights
                                for (let j = 0; j < d; j++) {
                                    this.weights[j] -= lr * (error * X[i][j] + lambda * this.weights[j]);
                                }
                                this.bias -= lr * error;
                            }
                        }
                    },
                    predict: function(x) {
                        if (!this.weights) return 0;
                        let sum = this.bias;
                        for (let i = 0; i < x.length; i++) {
                            sum += x[i] * this.weights[i];
                        }
                        return sum;
                    }
                };
            }

            async createMLPModel() {
                this.models.mlp = tf.sequential({
                    layers: [
                        tf.layers.dense({ units: 64, activation: 'relu', inputShape: [20] }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                this.models.mlp.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mse']
                });
            }

            async createLSTMModel() {
                this.models.lstm = tf.sequential({
                    layers: [
                        tf.layers.lstm({ units: 50, returnSequences: true, inputShape: [60, 10] }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.lstm({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                this.models.lstm.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mse']
                });
            }

            async createCNNModel() {
                this.models.cnn = tf.sequential({
                    layers: [
                        tf.layers.conv1d({ filters: 64, kernelSize: 3, activation: 'relu', inputShape: [60, 10] }),
                        tf.layers.maxPooling1d({ poolSize: 2 }),
                        tf.layers.conv1d({ filters: 32, kernelSize: 3, activation: 'relu' }),
                        tf.layers.globalMaxPooling1d(),
                        tf.layers.dense({ units: 50, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                this.models.cnn.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mse']
                });
            }

            async createTransformerModel() {
                // Simplified transformer architecture
                this.models.transformer = tf.sequential({
                    layers: [
                        tf.layers.dense({ units: 128, activation: 'relu', inputShape: [60] }),
                        tf.layers.layerNormalization(),
                        tf.layers.dense({ units: 64, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.1 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                this.models.transformer.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mse']
                });
            }

            async predict(features, modelName) {
                if (!this.initialized) return null;
                
                try {
                    if (modelName === 'ridge') {
                        return this.models.ridge.predict(features);
                    } else if (this.models[modelName]) {
                        const input = tf.tensor2d([features]);
                        const prediction = await this.models[modelName].predict(input).data();
                        input.dispose();
                        return prediction[0];
                    }
                } catch (error) {
                    console.error(`Prediction error for ${modelName}:`, error);
                    return null;
                }
            }

            async predictEnsemble(features) {
                const predictions = [];
                const weights = [0.15, 0.2, 0.25, 0.2, 0.15, 0.05]; // Model weights
                const modelNames = ['ridge', 'mlp', 'lstm', 'cnn', 'transformer'];
                
                for (let i = 0; i < modelNames.length; i++) {
                    const pred = await this.predict(features, modelNames[i]);
                    if (pred !== null) {
                        predictions.push(pred * weights[i]);
                    }
                }
                
                return predictions.reduce((a, b) => a + b, 0);
            }

            generateSignal(prediction, currentPrice, confidence) {
                const threshold = 0.002; // 0.2% movement threshold
                const signal = {
                    type: 'HOLD',
                    confidence: confidence,
                    price: currentPrice,
                    target: null,
                    stopLoss: null,
                    riskReward: null
                };
                
                if (prediction > currentPrice * (1 + threshold)) {
                    signal.type = 'BUY';
                    signal.target = currentPrice * 1.01; // 1% target
                    signal.stopLoss = currentPrice * 0.995; // 0.5% stop loss
                    signal.riskReward = 2.0;
                } else if (prediction < currentPrice * (1 - threshold)) {
                    signal.type = 'SELL';
                    signal.target = currentPrice * 0.99; // 1% target
                    signal.stopLoss = currentPrice * 1.005; // 0.5% stop loss
                    signal.riskReward = 2.0;
                }
                
                return signal;
            }
        }

        // Data Management and WebSocket Connection
        class DataManager {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.callbacks = {};
            }

            async fetchHistoricalData() {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${state.config.symbol}&interval=${state.config.interval}&limit=${state.config.limit}`);
                    const data = await response.json();
                    
                    return data.map(candle => ({
                        time: candle[0],
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    }));
                } catch (error) {
                    console.error('Error fetching historical data:', error);
                    return [];
                }
            }

            async fetchOrderBook() {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/depth?symbol=${state.config.symbol}&limit=20`);
                    const data = await response.json();
                    
                    return {
                        bids: data.bids.map(b => [parseFloat(b[0]), parseFloat(b[1])]),
                        asks: data.asks.map(a => [parseFloat(a[0]), parseFloat(a[1])])
                    };
                } catch (error) {
                    console.error('Error fetching order book:', error);
                    return { bids: [], asks: [] };
                }
            }

            async fetchRecentTrades() {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/trades?symbol=${state.config.symbol}&limit=100`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching recent trades:', error);
                    return [];
                }
            }

            connectWebSocket() {
                const wsUrl = `wss://stream.binance.com:9443/ws/${state.config.symbol.toLowerCase()}@kline_${state.config.interval}`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    this.reconnectAttempts = 0;
                    document.getElementById('binanceStatus').textContent = 'Connected';
                    
                    // Subscribe to additional streams
                    this.subscribeToStreams();
                };
                
                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleWebSocketMessage(data);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    document.getElementById('binanceStatus').textContent = 'Error';
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    document.getElementById('binanceStatus').textContent = 'Disconnected';
                    this.handleReconnection();
                };
            }

            subscribeToStreams() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const subscribeMsg = {
                        method: "SUBSCRIBE",
                        params: [
                            `${state.config.symbol.toLowerCase()}@trade`,
                            `${state.config.symbol.toLowerCase()}@depth@100ms`,
                            `${state.config.symbol.toLowerCase()}@aggTrade`
                        ],
                        id: 1
                    };
                    this.ws.send(JSON.stringify(subscribeMsg));
                }
            }

            handleWebSocketMessage(data) {
                if (data.e === 'kline') {
                    const candle = data.k;
                    const newCandle = {
                        time: candle.t,
                        open: parseFloat(candle.o),
                        high: parseFloat(candle.h),
                        low: parseFloat(candle.l),
                        close: parseFloat(candle.c),
                        volume: parseFloat(candle.v)
                    };
                    
                    // Update current price display
                    document.getElementById('currentPrice').textContent = candle.c;
                    
                    // Trigger callbacks
                    if (this.callbacks.onPriceUpdate) {
                        this.callbacks.onPriceUpdate(newCandle);
                    }
                } else if (data.e === 'trade') {
                    // Handle trade updates
                    if (this.callbacks.onTradeUpdate) {
                        this.callbacks.onTradeUpdate(data);
                    }
                } else if (data.e === 'depthUpdate') {
                    // Handle depth updates
                    if (this.callbacks.onDepthUpdate) {
                        this.callbacks.onDepthUpdate(data);
                    }
                }
            }

            handleReconnection() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    setTimeout(() => this.connectWebSocket(), 5000);
                }
            }

            on(event, callback) {
                this.callbacks[event] = callback;
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // Chart Manager
        class ChartManager {
            constructor() {
                this.chart = null;
                this.datasets = [];
                this.annotations = [];
            }

            initialize() {
                const ctx = document.getElementById('mainChart').getContext('2d');
                
                this.chart = new Chart(ctx, {
                    type: 'candlestick',
                    data: {
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            x: {
                                type: 'time',
                                grid: {
                                    color: 'rgba(100, 100, 150, 0.1)'
                                },
                                ticks: {
                                    color: '#9b9bb5',
                                    maxRotation: 0
                                }
                            },
                            y: {
                                position: 'right',
                                grid: {
                                    color: 'rgba(100, 100, 150, 0.1)'
                                },
                                ticks: {
                                    color: '#9b9bb5'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: '#9b9bb5',
                                    usePointStyle: true,
                                    boxWidth: 10
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(20, 20, 35, 0.95)',
                                titleColor: '#e0e0e0',
                                bodyColor: '#9b9bb5',
                                borderColor: 'rgba(100, 100, 150, 0.3)',
                                borderWidth: 1,
                                callbacks: {
                                    label: function(context) {
                                        if (context.raw && context.raw.o !== undefined) {
                                            return [
                                                `Open: ${context.raw.o.toFixed(4)}`,
                                                `High: ${context.raw.h.toFixed(4)}`,
                                                `Low: ${context.raw.l.toFixed(4)}`,
                                                `Close: ${context.raw.c.toFixed(4)}`,
                                                `Volume: ${context.raw.v?.toFixed(2) || 'N/A'}`
                                            ];
                                        }
                                        return `${context.dataset.label}: ${context.parsed.y?.toFixed(4) || 'N/A'}`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            updateCandlestickData(data) {
                const candlestickData = data.map(candle => ({
                    x: candle.time,
                    o: candle.open,
                    h: candle.high,
                    l: candle.low,
                    c: candle.close,
                    v: candle.volume
                }));

                const existingCandlestickIndex = this.chart.data.datasets.findIndex(d => d.label === 'WIF/USDT');
                
                if (existingCandlestickIndex !== -1) {
                    this.chart.data.datasets[existingCandlestickIndex].data = candlestickData;
                } else {
                    this.chart.data.datasets.push({
                        label: 'WIF/USDT',
                        type: 'candlestick',
                        data: candlestickData,
                        color: {
                            up: '#4caf50',
                            down: '#f44336',
                            unchanged: '#999'
                        }
                    });
                }
            }

            addIndicator(name, data, color, type = 'line') {
                const existingIndex = this.chart.data.datasets.findIndex(d => d.label === name);
                
                const dataset = {
                    label: name,
                    type: type,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: false
                };
                
                if (existingIndex !== -1) {
                    this.chart.data.datasets[existingIndex] = dataset;
                } else {
                    this.chart.data.datasets.push(dataset);
                }
            }

            removeIndicator(name) {
                const index = this.chart.data.datasets.findIndex(d => d.label === name);
                if (index !== -1) {
                    this.chart.data.datasets.splice(index, 1);
                }
            }

            addSignalMarkers(signals) {
                // Remove existing signal datasets
                this.chart.data.datasets = this.chart.data.datasets.filter(d => !d.label.includes('Signal'));
                
                const buySignals = signals.filter(s => s.type === 'BUY');
                const sellSignals = signals.filter(s => s.type === 'SELL');
                
                if (buySignals.length > 0) {
                    this.chart.data.datasets.push({
                        label: 'Buy Signals',
                        type: 'scatter',
                        data: buySignals.map(s => ({ x: s.time, y: s.price })),
                        backgroundColor: '#4caf50',
                        borderColor: '#4caf50',
                        pointStyle: 'triangle',
                        pointRadius: 8,
                        pointHoverRadius: 10
                    });
                }
                
                if (sellSignals.length > 0) {
                    this.chart.data.datasets.push({
                        label: 'Sell Signals',
                        type: 'scatter',
                        data: sellSignals.map(s => ({ x: s.time, y: s.price })),
                        backgroundColor: '#f44336',
                        borderColor: '#f44336',
                        pointStyle: 'triangleDown',
                        pointRadius: 8,
                        pointHoverRadius: 10
                    });
                }
            }

            update() {
                if (this.chart) {
                    this.chart.update('none');
                }
            }
        }

        // Trading System
        class TradingSystem {
            constructor() {
                this.trades = [];
                this.activePositions = [];
                this.performance = {
                    totalTrades: 0,
                    winningTrades: 0,
                    losingTrades: 0,
                    totalProfit: 0,
                    maxDrawdown: 0,
                    sharpeRatio: 0
                };
            }

            executeTrade(signal, model) {
                const trade = {
                    id: Date.now(),
                    timestamp: new Date(),
                    type: signal.type,
                    price: signal.price,
                    model: model,
                    confidence: signal.confidence,
                    target: signal.target,
                    stopLoss: signal.stopLoss,
                    riskReward: signal.riskReward,
                    status: 'ACTIVE',
                    result: null
                };
                
                this.trades.push(trade);
                this.activePositions.push(trade);
                
                this.updateTradesTable();
                return trade;
            }

            updateTradesTable() {
                const tbody = document.getElementById('tradesTableBody');
                tbody.innerHTML = '';
                
                const recentTrades = this.trades.slice(-10).reverse();
                
                recentTrades.forEach(trade => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${new Date(trade.timestamp).toLocaleTimeString()}</td>
                        <td class="signal-${trade.type.toLowerCase()}">${trade.type}</td>
                        <td>$${trade.price.toFixed(4)}</td>
                        <td>${trade.model}</td>
                        <td>${(trade.confidence * 100).toFixed(1)}%</td>
                        <td>$${trade.target ? trade.target.toFixed(4) : '-'}</td>
                        <td>$${trade.stopLoss ? trade.stopLoss.toFixed(4) : '-'}</td>
                        <td>${trade.riskReward ? trade.riskReward.toFixed(1) : '-'}</td>
                        <td>${trade.status}</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            calculatePerformance() {
                if (this.trades.length === 0) return;
                
                const returns = [];
                let capital = 10000; // Starting capital
                let maxCapital = capital;
                let minCapital = capital;
                
                this.trades.forEach(trade => {
                    if (trade.result) {
                        const profit = trade.result.profit;
                        capital += profit;
                        returns.push(profit / capital);
                        
                        if (capital > maxCapital) maxCapital = capital;
                        if (capital < minCapital) minCapital = capital;
                        
                        if (profit > 0) {
                            this.performance.winningTrades++;
                        } else {
                            this.performance.losingTrades++;
                        }
                        
                        this.performance.totalProfit += profit;
                    }
                });
                
                this.performance.totalTrades = this.trades.filter(t => t.result).length;
                this.performance.maxDrawdown = ((maxCapital - minCapital) / maxCapital) * 100;
                
                // Calculate Sharpe Ratio
                if (returns.length > 0) {
                    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const stdDev = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
                    this.performance.sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0;
                }
                
                this.updatePerformanceDisplay();
            }

            updatePerformanceDisplay() {
                const winRate = this.performance.totalTrades > 0 
                    ? (this.performance.winningTrades / this.performance.totalTrades * 100).toFixed(1)
                    : 0;
                
                document.getElementById('winRate').textContent = `${winRate}%`;
                document.getElementById('sharpeRatio').textContent = this.performance.sharpeRatio.toFixed(2);
                document.getElementById('maxDrawdown').textContent = `-${this.performance.maxDrawdown.toFixed(1)}%`;
            }
        }

        // Main Application
        class WIFPredictor {
            constructor() {
                this.dataManager = new DataManager();
                this.chartManager = new ChartManager();
                this.mlModels = new MLModels();
                this.tradingSystem = new TradingSystem();
                this.indicators = {};
                this.currentData = [];
                this.predictionInterval = null;
            }

            async initialize() {
                try {
                    // Initialize chart
                    this.chartManager.initialize();
                    
                    // Initialize ML models
                    await this.mlModels.initialize();
                    
                    // Fetch initial data
                    const historicalData = await this.dataManager.fetchHistoricalData();
                    this.currentData = historicalData;
                    
                    // Calculate initial indicators
                    this.calculateIndicators();
                    
                    // Update chart with initial data
                    this.updateChart();
                    
                    // Connect WebSocket
                    this.setupWebSocket();
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                    // Start prediction loop
                    this.startPredictionLoop();
                    
                    // Update UI
                    this.updateUI();
                    
                    // Hide loading overlay
                    document.getElementById('loadingOverlay').style.display = 'none';
                    
                } catch (error) {
                    console.error('Initialization error:', error);
                }
            }

            calculateIndicators() {
                if (this.currentData.length < 50) return;
                
                const closes = this.currentData.map(d => d.close);
                const highs = this.currentData.map(d => d.high);
                const lows = this.currentData.map(d => d.low);
                const volumes = this.currentData.map(d => d.volume);
                
                // Calculate all indicators
                this.indicators = {
                    ema9: TechnicalIndicators.calculateEMA(closes, 9),
                    ema21: TechnicalIndicators.calculateEMA(closes, 21),
                    sma20: TechnicalIndicators.calculateSMA(closes, 20),
                    sma50: TechnicalIndicators.calculateSMA(closes, 50),
                    macd: TechnicalIndicators.calculateMACD(closes),
                    rsi: TechnicalIndicators.calculateRSI(closes),
                    bb: TechnicalIndicators.calculateBollingerBands(closes),
                    atr: TechnicalIndicators.calculateATR(highs, lows, closes),
                    vwap: TechnicalIndicators.calculateVWAP(closes, volumes),
                    obv: TechnicalIndicators.calculateOBV(closes, volumes)
                };
                
                // Update indicator displays
                const latestRSI = this.indicators.rsi[this.indicators.rsi.length - 1];
                if (latestRSI) {
                    document.getElementById('rsiValue').textContent = latestRSI.toFixed(1);
                }
                
                const latestATR = this.indicators.atr[this.indicators.atr.length - 1];
                if (latestATR) {
                    document.getElementById('atrValue').textContent = latestATR.toFixed(4);
                }
            }

            updateChart() {
                // Update candlestick data
                this.chartManager.updateCandlestickData(this.currentData);
                
                // Update indicators based on toggles
                const times = this.currentData.map(d => d.time);
                
                if (document.getElementById('toggleEMA').checked) {
                    const ema9Data = this.indicators.ema9?.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    const ema21Data = this.indicators.ema21?.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    
                    if (ema9Data) this.chartManager.addIndicator('EMA 9', ema9Data, '#667eea');
                    if (ema21Data) this.chartManager.addIndicator('EMA 21', ema21Data, '#764ba2');
                } else {
                    this.chartManager.removeIndicator('EMA 9');
                    this.chartManager.removeIndicator('EMA 21');
                }
                
                if (document.getElementById('toggleSMA').checked) {
                    const sma20Data = this.indicators.sma20?.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    const sma50Data = this.indicators.sma50?.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    
                    if (sma20Data) this.chartManager.addIndicator('SMA 20', sma20Data, '#ffa726');
                    if (sma50Data) this.chartManager.addIndicator('SMA 50', sma50Data, '#ff7043');
                } else {
                    this.chartManager.removeIndicator('SMA 20');
                    this.chartManager.removeIndicator('SMA 50');
                }
                
                if (document.getElementById('toggleBB').checked && this.indicators.bb) {
                    const bbUpperData = this.indicators.bb.upper.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    const bbLowerData = this.indicators.bb.lower.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    const bbMiddleData = this.indicators.bb.middle.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    
                    this.chartManager.addIndicator('BB Upper', bbUpperData, '#42a5f5');
                    this.chartManager.addIndicator('BB Lower', bbLowerData, '#42a5f5');
                    this.chartManager.addIndicator('BB Middle', bbMiddleData, '#90caf9');
                } else {
                    this.chartManager.removeIndicator('BB Upper');
                    this.chartManager.removeIndicator('BB Lower');
                    this.chartManager.removeIndicator('BB Middle');
                }
                
                if (document.getElementById('toggleVWAP').checked && this.indicators.vwap) {
                    const vwapData = this.indicators.vwap.map((v, i) => ({ x: times[i], y: v })).filter(d => d.y !== null);
                    this.chartManager.addIndicator('VWAP', vwapData, '#ab47bc');
                } else {
                    this.chartManager.removeIndicator('VWAP');
                }
                
                this.chartManager.update();
            }

            setupWebSocket() {
                this.dataManager.connectWebSocket();
                
                this.dataManager.on('onPriceUpdate', (candle) => {
                    // Update current data
                    const existingIndex = this.currentData.findIndex(d => d.time === candle.time);
                    if (existingIndex !== -1) {
                        this.currentData[existingIndex] = candle;
                    } else {
                        this.currentData.push(candle);
                        if (this.currentData.length > 500) {
                            this.currentData.shift();
                        }
                    }
                    
                    // Recalculate indicators
                    this.calculateIndicators();
                    
                    // Update chart
                    this.updateChart();
                });
            }

            setupEventListeners() {
                // Indicator toggles
                ['EMA', 'SMA', 'MACD', 'RSI', 'BB', 'VWAP', 'ATR', 'OBV'].forEach(indicator => {
                    const toggle = document.getElementById(`toggle${indicator}`);
                    if (toggle) {
                        toggle.addEventListener('change', () => this.updateChart());
                    }
                });
                
                // Model toggles
                ['Ridge', 'MLP', 'LSTM', 'CNN', 'Transformer', 'Ensemble'].forEach(model => {
                    const toggle = document.getElementById(`toggle${model}`);
                    if (toggle) {
                        toggle.addEventListener('change', () => this.runPredictions());
                    }
                });
            }

            async startPredictionLoop() {
                // Run predictions every 5 seconds
                this.predictionInterval = setInterval(async () => {
                    await this.runPredictions();
                }, 5000);
                
                // Run initial prediction
                await this.runPredictions();
            }

            async runPredictions() {
                if (this.currentData.length < 100) return;
                
                try {
                    // Get latest data for features
                    const orderbook = await this.dataManager.fetchOrderBook();
                    const trades = await this.dataManager.fetchRecentTrades();
                    
                    // Extract features
                    const microFeatures = FeatureEngineering.extractMicrostructureFeatures(orderbook, trades);
                    const closes = this.currentData.map(d => d.close);
                    const volumes = this.currentData.map(d => d.volume);
                    
                    // Create feature vector
                    const features = FeatureEngineering.createFeatureVector(
                        closes.slice(-100),
                        volumes.slice(-100),
                        this.indicators,
                        microFeatures
                    );
                    
                    // Pad features to correct size for models
                    while (features.length < 20) {
                        features.push(0);
                    }
                    
                    const currentPrice = closes[closes.length - 1];
                    const signals = [];
                    
                    // Run predictions for each enabled model
                    if (document.getElementById('toggleRidge').checked) {
                        const pred = await this.mlModels.predict(features, 'ridge');
                        if (pred) {
                            const signal = this.mlModels.generateSignal(pred, currentPrice, 0.65);
                            if (signal.type !== 'HOLD') {
                                signal.model = 'Ridge';
                                signals.push(signal);
                            }
                        }
                    }
                    
                    if (document.getElementById('toggleMLP').checked) {
                        const pred = await this.mlModels.predict(features, 'mlp');
                        if (pred) {
                            const signal = this.mlModels.generateSignal(pred, currentPrice, 0.72);
                            if (signal.type !== 'HOLD') {
                                signal.model = 'MLP';
                                signals.push(signal);
                            }
                        }
                    }
                    
                    if (document.getElementById('toggleEnsemble').checked) {
                        const pred = await this.mlModels.predictEnsemble(features);
                        if (pred) {
                            const signal = this.mlModels.generateSignal(pred, currentPrice, 0.85);
                            if (signal.type !== 'HOLD') {
                                signal.model = 'Ensemble';
                                signals.push(signal);
                                
                                // Execute trade for high confidence signals
                                if (signal.confidence > 0.8) {
                                    this.tradingSystem.executeTrade(signal, 'Ensemble');
                                }
                            }
                        }
                    }
                    
                    // Update signal markers on chart
                    if (document.getElementById('toggleSignals').checked) {
                        const signalsWithTime = signals.map(s => ({
                            ...s,
                            time: Date.now()
                        }));
                        this.chartManager.addSignalMarkers(signalsWithTime);
                        this.chartManager.update();
                    }
                    
                    // Update prediction count
                    const predCount = parseInt(document.getElementById('predictionCount').textContent) + signals.length;
                    document.getElementById('predictionCount').textContent = predCount;
                    
                    // Calculate whale pressure
                    const whalePressure = FeatureEngineering.calculateWhalePressureIndex([], currentPrice, volumes[volumes.length - 1]);
                    document.getElementById('whalePressure').textContent = whalePressure.toFixed(1);
                    
                } catch (error) {
                    console.error('Prediction error:', error);
                }
            }

            updateUI() {
                // Update 24h volume
                fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${state.config.symbol}`)
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById('volume24h').textContent = parseFloat(data.volume).toLocaleString();
                    });
                
                // Update performance metrics periodically
                setInterval(() => {
                    this.tradingSystem.calculatePerformance();
                }, 10000);
            }
        }

        // Global functions for button actions
        async function retrainModels() {
            alert('Model retraining initiated. This process will run in the background.');
            // Implement actual retraining logic here
        }

        async function runBacktest() {
            alert('Backtesting initiated. Results will be displayed shortly.');
            // Implement backtesting logic here
        }

        async function exportData() {
            const dataToExport = {
                priceData: state.priceData,
                indicators: state.indicators,
                trades: app.tradingSystem.trades,
                performance: app.tradingSystem.performance
            };
            
            const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `wif-usdt-data-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize application
        let app;
        
        window.addEventListener('DOMContentLoaded', async () => {
            app = new WIFPredictor();
            await app.initialize();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (app && app.dataManager) {
                app.dataManager.disconnect();
            }
        });
    </script>
</body>
</html>
