<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT All-in-One Price Predictor</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        h1, h3 {
            text-align: center;
            color: #E6A400;
        }
        .main-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }
        #controls {
            background-color: #2b2b2b;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #controls label {
            display: block;
            cursor: pointer;
        }
        #controls button {
            background-color: #E6A400;
            color: #131722;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }
        #controls button:hover {
            background-color: #ffc107;
        }
        #chart-container {
            flex-grow: 1;
            max-width: 1200px;
            border: 1px solid #333;
        }
        #trade-log {
            max-width: 1300px;
            margin: 20px auto;
            background-color: #2b2b2b;
            padding: 20px;
            border-radius: 8px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #333;
        }
        .buy { color: #26a69a; font-weight: bold; }
        .sell { color: #ef5350; font-weight: bold; }
    </style>
</head>
<body>

    <h1>WIF/USDT Browser ML Price-Predictor</h1>

    <div class="main-container">
        <div id="controls">
            <h3>Controls</h3>
            <label><input type="checkbox" id="toggle-rsi" checked> RSI (14)</label>
            <label><input type="checkbox" id="toggle-bbands"> Bollinger Bands (20, 2)</label>
            <hr>
            <h3>Models</h3>
            <label><input type="checkbox" id="toggle-mlp-signal" checked> Show MLP Signals</label>
            <hr>
            <button id="run-backtest">Run Backtest (Console)</button>
        </div>

        <div id="chart-container"></div>
    </div>

    <div id="trade-log">
        <h3>Live Trade Signals Log</h3>
        <table id="trade-table">
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>Type</th>
                    <th>Price</th>
                    <th>Reason</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>

<script>
// ===================================================================================
// --- All JavaScript Logic Contained in this Single Script Block ---
// ===================================================================================

// --- !!! DANGEROUS !!! ---
// Storing API keys here is a major security risk. They will be stolen if you deploy this.
// For local testing only. Replace with your actual keys.
const INSECURE_API_KEYS = {
    WHALE_ALERT_API_KEY: 'YOUR_WHALE_ALERT_API_KEY_HERE',
    BITQUERY_API_KEY: 'YOUR_BITQUERY_API_KEY_HERE'
};


// ===================================================================================
// --- MODULE 1: API (Data Fetching) ---
// ===================================================================================
const API = {
    /**
     * Fetches historical k-line (candlestick) data from Binance. Public API, no key needed.
     */
    async getBinanceKlines(symbol = 'WIFUSDT', interval = '5m', limit = 1000) {
        const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Binance API error: ${response.statusText}`);
            const data = await response.json();
            return data.map(k => ({
                time: k[0] / 1000,
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            }));
        } catch (error) {
            console.error("Failed to fetch Binance klines:", error);
            return [];
        }
    },

    /**
     * Fetches whale alert data. REQUIRES a secure backend in production.
     */
    async getWhaleAlerts() {
        if (INSECURE_API_KEYS.WHALE_ALERT_API_KEY === 'YOUR_WHALE_ALERT_API_KEY_HERE') return null;
        const url = `https://api.whale-alert.io/v1/transactions?api_key=${INSECURE_API_KEYS.WHALE_ALERT_API_KEY}&currency=wif&min_value=500000`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error('Whale Alert API error');
            return await response.json();
        } catch (error) {
            console.error("Failed to fetch whale alerts:", error);
            return null;
        }
    }
};


// ===================================================================================
// --- MODULE 2: FEATURES (Indicator Calculations) ---
// ===================================================================================
const Features = {
    /**
     * Calculates Simple Moving Average (SMA).
     */
    calculateSMA(data, period) {
        let sma = [];
        for (let i = 0; i < data.length; i++) {
            if (i >= period - 1) {
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                sma.push({ time: data[i].time, value: sum / period });
            } else {
                sma.push({ time: data[i].time, value: undefined });
            }
        }
        return sma;
    },

    /**
     * Calculates Bollinger Bands (BBands).
     */
    calculateBollingerBands(data, period = 20, stdDev = 2) {
        let bbands = [];
        for (let i = 0; i < data.length; i++) {
            if (i >= period - 1) {
                const slice = data.slice(i - period + 1, i + 1);
                const sma = slice.reduce((a, b) => a + b.close, 0) / period;
                const variance = slice.reduce((a, b) => a + Math.pow(b.close - sma, 2), 0) / period;
                const deviation = Math.sqrt(variance);
                bbands.push({
                    time: data[i].time,
                    upper: sma + stdDev * deviation,
                    middle: sma,
                    lower: sma - stdDev * deviation
                });
            } else {
                bbands.push({ time: data[i].time, upper: undefined, middle: undefined, lower: undefined });
            }
        }
        return bbands;
    },

    /**
     * Calculates Relative Strength Index (RSI).
     */
    calculateRSI(data, period = 14) {
        let rsi = [];
        let avgGain = 0, avgLoss = 0;
        
        for (let i = 1; i < data.length; i++) {
            const change = data[i].close - data[i-1].close;
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;

            if (i < period) {
                avgGain += gain;
                avgLoss += loss;
                rsi.push({ time: data[i].time, value: undefined });
                continue;
            }
            if (i === period) {
                avgGain = (avgGain + gain) / period;
                avgLoss = (avgLoss + loss) / period;
            } else {
                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;
            }

            if (avgLoss === 0) {
                rsi.push({ time: data[i].time, value: 100 });
            } else {
                const rs = avgGain / avgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push({ time: data[i].time, value: rsiValue });
            }
        }
        rsi.unshift({ time: data[0].time, value: undefined }); // Pad start
        return rsi;
    }
};


// ===================================================================================
// --- MODULE 3: MODELS (TensorFlow.js Logic) ---
// ===================================================================================
const ModelHandler = {
    mlpModel: null,

    /**
     * Creates a simple Multi-Layer Perceptron (MLP) model.
     */
    createMLP(inputShape) {
        const model = tf.sequential();
        model.add(tf.layers.dense({ inputShape: [inputShape], units: 50, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 25, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 1, activation: 'linear' })); // Predict next price return

        model.compile({ optimizer: tf.train.adam(0.01), loss: 'meanSquaredError' });
        
        this.mlpModel = model;
        console.log("MLP Model Created.", this.mlpModel);
        return model;
    },
    
    /**
     * Makes a prediction using the loaded MLP model.
     */
    async predict(latestFeatures) {
        if (!this.mlpModel) return null;

        return tf.tidy(() => {
            const inputTensor = tf.tensor2d([latestFeatures]);
            const prediction = this.mlpModel.predict(inputTensor);
            return prediction.dataSync()[0];
        });
    }
};


// ===================================================================================
// --- MODULE 4: UI (Chart and DOM Management) ---
// ===================================================================================
const UI = {
    chart: null,
    series: {},

    initChart() {
        this.chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
            width: document.getElementById('chart-container').clientWidth,
            height: 600,
            layout: { backgroundColor: '#131722', textColor: '#d1d4dc' },
            grid: { vertLines: { color: '#334158' }, horzLines: { color: '#334158' } },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            timeScale: { timeVisible: true, secondsVisible: false },
        });
        this.series.candlestick = this.chart.addCandlestickSeries();
    },

    updateCandlestickData(data) {
        this.series.candlestick.setData(data);
    },
    
    toggleRSI(data, visible) {
        if (visible) {
            if (!this.series.rsi) {
                this.series.rsi = this.chart.addLineSeries({
                    color: '#E6A400', lineWidth: 2, priceScaleId: 'rsi',
                });
                this.chart.priceScale('rsi').applyOptions({
                    scaleMargins: { top: 0.8, bottom: 0 }, height: 100
                });
            }
            this.series.rsi.setData(data.filter(d => d.value !== undefined));
        } else if (this.series.rsi) {
            this.chart.removeSeries(this.series.rsi);
            delete this.series.rsi;
        }
    },
    
    toggleBollingerBands(data, visible) {
        if (visible) {
            if (!this.series.bbands_upper) {
                const options = { color: 'rgba(76, 175, 80, 0.4)', lineWidth: 1, priceLineVisible: false };
                this.series.bbands_upper = this.chart.addLineSeries(options);
                this.series.bbands_lower = this.chart.addLineSeries(options);
                
                const fill = this.chart.addAreaSeries({
                    topLineColor: 'rgba(76, 175, 80, 0.4)',
                    bottomLineColor: 'rgba(76, 175, 80, 0.4)',
                    topColor: 'rgba(76, 175, 80, 0.1)',
                    bottomColor: 'rgba(76, 175, 80, 0.1)',
                    priceLineVisible: false,
                });
                
                const fillData = data.map(d => ({time: d.time, value: d.upper, open: d.lower}));
                fill.setData(fillData.filter(d => d.value !== undefined));
                
                this.series.bbands_fill = fill;
            }
            this.series.bbands_upper.setData(data.map(d => ({time: d.time, value: d.upper})).filter(d => d.value !== undefined));
            this.series.bbands_lower.setData(data.map(d => ({time: d.time, value: d.lower})).filter(d => d.value !== undefined));
        } else if (this.series.bbands_upper) {
            this.chart.removeSeries(this.series.bbands_upper);
            this.chart.removeSeries(this.series.bbands_lower);
            this.chart.removeSeries(this.series.bbands_fill);
            delete this.series.bbands_upper;
            delete this.series.bbands_lower;
            delete this.series.bbands_fill;
        }
    },

    addTradeSignal(time, type, price) {
        const existingMarkers = this.series.candlestick.markers();
        const newMarker = {
            time,
            position: type === 'buy' ? 'belowBar' : 'aboveBar',
            color: type === 'buy' ? '#26a69a' : '#ef5350',
            shape: type === 'buy' ? 'arrowUp' : 'arrowDown',
            text: type.toUpperCase()
        };
        this.series.candlestick.setMarkers([...existingMarkers, newMarker]);
    },
    
    addTradeToLog(trade) {
        const tableBody = document.querySelector("#trade-table tbody");
        const row = tableBody.insertRow(0); // Add to top
        row.innerHTML = `
            <td>${new Date(trade.time * 1000).toLocaleString()}</td>
            <td class="${trade.type}">${trade.type.toUpperCase()}</td>
            <td>${trade.price.toFixed(4)}</td>
            <td>${trade.reason}</td>
        `;
    }
};


// ===================================================================================
// --- MODULE 5: APP (Main Controller) ---
// ===================================================================================
const App = {
    klines: [],
    features: {},
    
    async init() {
        console.log("Initializing application...");
        UI.initChart();
        
        await this.loadDataAndFeatures();
        
        // Example: Use RSI and the close price's % change as features for the MLP
        ModelHandler.createMLP(2); // 2 input features

        this.updateUI();
        this.setupEventListeners();

        // Perform an initial prediction
        this.runPrediction();

        // Start live update loop
        setInterval(() => this.liveUpdate(), 60000); // Update every 60 seconds
    },

    async loadDataAndFeatures() {
        this.klines = await API.getBinanceKlines();
        this.features.rsi = Features.calculateRSI(this.klines);
        this.features.bbands = Features.calculateBollingerBands(this.klines);
    },
    
    async liveUpdate() {
        console.log("Fetching live data...");
        const latestKlines = await API.getBinanceKlines('WIFUSDT', '5m', 2);
        const newCandle = latestKlines[0];
        const lastKlineInChart = this.klines[this.klines.length - 1];

        if (newCandle.time > lastKlineInChart.time) {
            this.klines.push(newCandle); // New candle
            this.klines.shift(); // Keep array size constant
        } else {
            this.klines[this.klines.length - 1] = newCandle; // Update current candle
        }
        
        // Recalculate all features
        this.features.rsi = Features.calculateRSI(this.klines);
        this.features.bbands = Features.calculateBollingerBands(this.klines);
        
        this.updateUI();
        await this.runPrediction();
    },
    
    async runPrediction() {
        if (!document.getElementById('toggle-mlp-signal').checked) return;
        
        // Prepare the latest features for the model
        const lastIndex = this.klines.length - 1;
        const lastRSI = this.features.rsi[lastIndex]?.value;
        const prevClose = this.klines[lastIndex - 1]?.close;
        const lastClose = this.klines[lastIndex]?.close;
        
        // Check if data is valid
        if (!lastRSI || !prevClose || !lastClose) {
            console.log("Not enough data for prediction yet.");
            return;
        }

        const pctChange = (lastClose - prevClose) / prevClose;
        const featureVector = [lastRSI / 100, pctChange]; // Normalize features
        
        const prediction = await ModelHandler.predict(featureVector);
        if (prediction === null) return;
        
        console.log("MLP Predicted Return:", prediction);
        const signalTime = this.klines[lastIndex].time;
        
        // Simple signal logic based on predicted return
        const threshold = 0.001; // 0.1% predicted move
        if (prediction > threshold) {
            UI.addTradeSignal(signalTime, 'buy', lastClose);
            UI.addTradeToLog({ time: signalTime, type: 'buy', price: lastClose, reason: 'MLP Signal (Pred > 0.1%)' });
        } else if (prediction < -threshold) {
            UI.addTradeSignal(signalTime, 'sell', lastClose);
            UI.addTradeToLog({ time: signalTime, type: 'sell', price: lastClose, reason: 'MLP Signal (Pred < -0.1%)' });
        }
    },

    updateUI() {
        UI.updateCandlestickData(this.klines);
        UI.toggleRSI(this.features.rsi, document.getElementById('toggle-rsi').checked);
        UI.toggleBollingerBands(this.features.bbands, document.getElementById('toggle-bbands').checked);
    },
    
    setupEventListeners() {
        document.getElementById('toggle-rsi').addEventListener('change', () => this.updateUI());
        document.getElementById('toggle-bbands').addEventListener('change', () => this.updateUI());
        
        // Placeholder for backtesting logic
        document.getElementById('run-backtest').addEventListener('click', () => {
             console.log("Backtesting not fully implemented in this single-file example.");
             alert("Backtesting requires more complex logic. See console for details.");
        });
    }
};

// --- Entry Point ---
document.addEventListener('DOMContentLoaded', () => App.init());

</script>

</body>
</html>
