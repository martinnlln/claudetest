<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WIF/USDT ML Price Predictor</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
body { font-family: Arial; margin: 0; padding: 0; background: #0f0f0f; color: #fff;}
#controls { padding: 10px; display: flex; flex-wrap: wrap; gap: 10px; background: #111;}
button { padding: 5px 10px; cursor: pointer; }
#chart { height: 600px; }
#trade-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
#trade-table th, #trade-table td { border: 1px solid #444; padding: 4px; text-align: center; }
</style>
</head>
<body>

<div id="controls">
  <button onclick="toggleSeries('EMA')">Toggle EMA</button>
  <button onclick="toggleSeries('SMA')">Toggle SMA</button>
  <button onclick="toggleSeries('MACD')">Toggle MACD</button>
  <button onclick="toggleSeries('RSI')">Toggle RSI</button>
  <button onclick="toggleSeries('BuySell')">Toggle Buy/Sell</button>
  <button onclick="trainMLP()">Train MLP</button>
</div>

<div id="chart"></div>
<table id="trade-table">
  <thead>
    <tr><th>Time</th><th>Price</th><th>Qty</th><th>Signal</th></tr>
  </thead>
  <tbody id="trade-body"></tbody>
</table>

<script>
/************* Data Layer *************/
let trades = [];
let candles = [];
let depth = { bids: [], asks: [] };
let indicators = {};
let signals = [];

const ws = new WebSocket("wss://stream.binance.com:9443/ws/wifusdt@trade");
ws.onmessage = msg => {
  const data = JSON.parse(msg.data);
  const price = parseFloat(data.p);
  const qty = parseFloat(data.q);
  const time = data.T;
  trades.push({ price, qty, time });
  addCandle(price, time);
  updateIndicators();
  generateSignals();
  updateChart();
  updateTable();
};

/************* Candle Aggregation (1m) *************/
function addCandle(price, time) {
  const minute = Math.floor(time / 60000);
  let candle = candles[candles.length-1];
  if(!candle || candle.minute !== minute){
    candle = { time: time, open: price, high: price, low: price, close: price, volume: 0, minute };
    candles.push(candle);
  } else {
    candle.high = Math.max(candle.high, price);
    candle.low = Math.min(candle.low, price);
    candle.close = price;
  }
  candle.volume += qty;
}

/************* Indicators *************/
function EMA(values, period){
  const k = 2/(period+1);
  let ema = [values[0]];
  for(let i=1;i<values.length;i++){
    ema.push(values[i]*k + ema[i-1]*(1-k));
  }
  return ema;
}
function SMA(values, period){
  let sma = [];
  for(let i=0;i<values.length;i++){
    if(i<period) { sma.push(values[i]); continue; }
    let sum=0;
    for(let j=i-period+1;j<=i;j++) sum+=values[j];
    sma.push(sum/period);
  }
  return sma;
}
function RSI(values, period=14){
  let rsis = [];
  for(let i=0;i<values.length;i++){
    if(i<period){ rsis.push(50); continue; }
    let gain=0, loss=0;
    for(let j=i-period+1;j<=i;j++){
      let diff = values[j]-values[j-1];
      if(diff>0) gain+=diff; else loss-=diff;
    }
    let rs = gain/(loss||1);
    rsis.push(100-100/(1+rs));
  }
  return rsis;
}
function MACD(values, fast=12, slow=26, signal=9){
  let emaFast = EMA(values, fast);
  let emaSlow = EMA(values, slow);
  let macd = emaFast.map((v,i)=>v-emaSlow[i]);
  let signalLine = EMA(macd, signal);
  return { macd, signalLine };
}

/************* Feature Update & Signals *************/
function updateIndicators(){
  const closes = candles.map(c=>c.close);
  indicators.EMA = EMA(closes, 20);
  indicators.SMA = SMA(closes, 20);
  indicators.RSI = RSI(closes, 14);
  const macdObj = MACD(closes);
  indicators.MACD = macdObj.macd;
  indicators.MACDSignal = macdObj.signalLine;
}

function generateSignals(){
  const len = candles.length;
  if(len<2) return;
  const lastPrice = candles[len-1].close;
  const ema = indicators.EMA[len-1];
  const rsi = indicators.RSI[len-1];
  let signal = "";
  if(lastPrice>ema && rsi<70) signal="BUY";
  if(lastPrice<ema && rsi>30) signal="SELL";
  signals.push({ time: candles[len-1].time, price:lastPrice, type: signal });
}

/************* Chart *************/
const chart = LightweightCharts.createChart(document.getElementById('chart'), { width: window.innerWidth, height:600, layout: { background: { color:'#0f0f0f'}, textColor:'#fff' }, grid:{ vertLines:{ color:'#444' }, horzLines:{color:'#444'} }});
const candleSeries = chart.addCandlestickSeries();
let emaSeries = chart.addLineSeries({ color:'yellow', visible:true });
let smaSeries = chart.addLineSeries({ color:'orange', visible:true });
let macdSeries = chart.addLineSeries({ color:'cyan', visible:true });
let buySellSeries = chart.addScatterSeries({ color:'green', shape:'arrowUp', visible:true });

function updateChart(){
  candleSeries.setData(candles.map(c=>({ time:c.time/1000, open:c.open, high:c.high, low:c.low, close:c.close })));
  emaSeries.setData(indicators.EMA.map((v,i)=>({ time:candles[i].time/1000, value:v })));
  smaSeries.setData(indicators.SMA.map((v,i)=>({ time:candles[i].time/1000, value:v })));
  macdSeries.setData(indicators.MACD.map((v,i)=>({ time:candles[i].time/1000, value:v })));
  buySellSeries.setData(signals.filter(s=>s.type!=="").map(s=>({ time:s.time/1000, value:s.price })));
}

/************* Toggle Series *************/
function toggleSeries(name){
  switch(name){
    case 'EMA': emaSeries.applyOptions({ visible: !emaSeries.options().visible }); break;
    case 'SMA': smaSeries.applyOptions({ visible: !smaSeries.options().visible }); break;
    case 'MACD': macdSeries.applyOptions({ visible: !macdSeries.options().visible }); break;
    case 'BuySell': buySellSeries.applyOptions({ visible: !buySellSeries.options().visible }); break;
  }
}

/************* Trade Table *************/
function updateTable(){
  const tbody = document.getElementById('trade-body');
  tbody.innerHTML = "";
  trades.slice(-20).forEach(tr=>{
    const sig = signals.find(s=>s.time===tr.time);
    const trEl = document.createElement('tr');
    trEl.innerHTML = `<td>${new Date(tr.time).toLocaleTimeString()}</td><td>${tr.price}</td><td>${tr.qty}</td><td>${sig?sig.type:""}</td>`;
    tbody.appendChild(trEl);
  });
}

/************* MLP Training *************/
let mlpModel=null;
function trainMLP(){
  const closes = candles.map(c=>c.close);
  if(closes.length<60) return alert("Need more candles to train");
  const X = [];
  const y = [];
  for(let i=60;i<closes.length;i++){
    X.push(closes.slice(i-60,i));
    y.push(closes[i]);
  }
  const Xtensor = tf.tensor2d(X);
  const ytensor = tf.tensor2d(y, [y.length,1]);
  mlpModel = tf.sequential();
  mlpModel.add(tf.layers.dense({ units:64, activation:'relu', inputShape:[60] }));
  mlpModel.add(tf.layers.dense({ units:32, activation:'relu' }));
  mlpModel.add(tf.layers.dense({ units:1 }));
  mlpModel.compile({ optimizer:'adam', loss:'meanSquaredError' });
  mlpModel.fit(Xtensor, ytensor, { epochs:20 }).then(()=>{
    alert("MLP trained!");
  });
}
</script>
</body>
</html>
